---
title: Grumpy Old Men, Opacity, and Optimizers
date: 2014/09/09
slug: grumpy-old-men-opacity-and-optimizers
---

<p>Today I'm channeling my inner grumpy old man. And these guys are helping. (I am not old enough to pull off such a face by myself, although life is rapidly helping me get there. ;-)</p><p>[embed]https://www.flickr.com/photos/neilmoralee/6244499091/sizes/z/[/embed]</p><p>The reason I'm feeling grumpy is that I've had another in a long, long line of conversations about how to write faster code.</p><p>It's not that optimization experts are dumb. Far from it. They are invariably smart, and in general, they are better informed than I am about how pipeline burst cache and GPUs and RAM prefetch algorithms work. I generally learn a lot when I talk to guys like this.</p><p>I applaud their passion, even if I think <a title="3 Commandments of Performance Optimization" href="../../../2013/01/08/3-commandments-of-performance-optimization/">they sometimes get carried away</a>.</p><p>No. What's making me grumpy is that after decades of hard work, we still have compilers that encourage a culture of black magic and superstition around this topic. I thought I signed up for computer science, not voodoo.</p><p>To show you what I mean, let's talk about the humble <code>inline</code> keyword in C and C++. The amount of FUD and nonsense around it is really unfortunate. How many of the following have you heard?<br /> <!--more--></p><ul><li>Inlines are always faster than normal function calls.</li><li>Inlines are sometimes slower than normal function calls, if they bloat the binary to the point where the data segment causes page faults.</li><li>Compilers treat <code>inline</code> as a hint only, and ignore it whenever they feel like it.</li><li>Ordinary programmers might not be smarter than the compiler, but I am. That's why I use the compiler extension that always inlines, instead of just the ordinary <code>inline</code> keyword that's useless.</li><li>If you declare a <code>static</code> in a function, it can't be inlined.</li><li>If you throw an exception in a function, it can't be inlined.</li><li>If you call a virtual in a function, it can't be inlined.</li><li>If you call <code>goto</code> in a function, it can't be inlined.</li><li>If you use thread-local storage in a function, it can't be inlined.</li><li>Only code in a header can be inlined. Using <code>inline</code> in a .cpp is either an error or is totally ignored by the compiler.</li><li>Since templates are implemented in headers, they are automatically inline candidates.</li><li><code>static</code> and <code>inline</code> are mutually contradictory.</li></ul><p>I'm not going to argue the stuff in the above list, one way or another. There's enough falsehood in that list to steer people wrong, and enough truth in it to be dangerous. Importantly, all of the items in the list are stated as timeless, universal truths, which is a <em>prime facie</em> reason to treat the list a <span style="color:#808000;">Bad Idea™</span> regardless. Remember: <a title="Steve Tolman: It depends." href="../../../2012/09/17/steve-tolman-it-depends/">it depends</a>. :-)</p><p>My point today is not about inlines, though. It's not even about performance dogma. Rather, it's about opacity.</p><p>The optimization choices that a compiler makes about inlining and sundry other issues are <em>opaque</em> to most coders. And I claim that it is this fact--not irrational zealots--at the heart of a lot of holy wars, debates, and FUD about optimization. The classic paper by <a href="http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726" target="_blank">Meyers and Alexandrescu about how compiler optimization defeats the intent of the double-checked locking pattern</a> provides eloquent examples of this opacity. If you haven't read it, I encourage you to do so.</p><p>We should fix this.</p><p>Compiler makers, I hereby request a feature. Please add the ability to generate an "optimization plan" for a function, analogous to the "explain query plan" feature that DB admins have used to tune their work for decades.</p><p>I can imagine this working as a compiler switch, similar to <code>-E</code> which dumps preprocessor output to stdout. If I add <code>--explain-optimizations</code> to the cmdline, I would like a report that tells me:</p><ul><li>What sorts of loop unwinding, reordering, and other shortcuts will be used. Please tie them back to the specific switches that are active.</li><li>How optimizations were constrained by block, function, and translation unit scope--and how optimizations might change naive assumptions about scope that a programmer would form by looking at the high-level representation of the code.</li><li>What additional optimizations might be possible if additional switches were added or removed.</li><li>What guesses were made about likely versus unlikely branches in conditionals.</li><li>What additional optimizations might be possible if not for a certain characteristic of the code. Please be specific: "I could not optimize out the extra assignment to foo, because codepath X requires it."</li><li>How micro optimization decisions conflict with macro ones, and what assumptions and priorities were used to resolve these conflicts.</li></ul><p>I realize I am not asking for something easy. But I believe explaining optimization choices cannot be harder than making those choices in the first place--and the problem must be somewhat tractable, since the SQL crowd has an analogous tool.</p><p>Let's shine some light on this black magic, and turn performance tradeoffs into a science based on common, abundant knowledge. I think it could improve the whole industry.</p><hr /><p style="text-align:right;color:gray;font-size:85%;">Image credit: <a href="https://www.flickr.com/photos/neilmoralee/6244499091/sizes/l">Neil. Moralee (Flickr)</a></p>