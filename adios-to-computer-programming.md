---
title: Adios to "computer programming"
date: 2013-04-05
slug: adios-to-computer-programming
---

Have you noticed how seldom people put the modifier "computer" in front of "programming" nowadays?

This may be because our formerly esoteric discipline is now so mainstream that it needs no elaboration.

It may be that we're all growing lazy.

But I think there's something deeper.

<strong>"Software Engineering" isn't good enough</strong>

The set of things besides traditional computers that need to be programmed is growing by leaps and bounds: TV remotes, holiday light displays, e-readers, smartphones and tablets, <a class="zem_slink" title="Arduino" href="http://arduino.cc" target="_blank" rel="homepage">Arduino</a> boards, fuel injectors, point-of-sale terminals, MRI machines, 3D printers, LEGO MindStorm robots, networks (software-defined networking / <a title="Software-defined networking" href="http://en.wikipedia.org/wiki/Software-defined_networking" target="_blank" rel="wikipedia">SDN</a>), storage (<a title="Software defined storage" href="http://en.wikipedia.org/wiki/Software_defined_storage" target="_blank" rel="wikipedia">software-defined storage</a> / SDS), nanobots, social networks, clouds...

<figure><img alt="" src="http://farm1.staticflickr.com/229/484826733_713c781d55.jpg" width="432" height="288" /><figcaption>Nanobots replicating in a petri dish. Is it fair to say we "program" nanobots? Photo credit: PhOtOnQuAnTiQuE (Flickr)</figcaption></figure>

"Right," I hear you say. "That's why I like the term <em>software engineering</em>. Wherever you see programming, it's software that's in play. And engineering implies a more sophisticated approach than mere hackish programming."

Okay.

I think that's true, but it misses the really <em>big</em> insight.<!--more-->

<strong>Systems thinking is the wave of the future</strong>

Technology is evolving--rapidly--to depend upon complex <em>systems</em>, not isolated devices, as the dominant unit of value delivery. More and more often, programming tasks demand a greater scope of design than a single computer.

That's big.

The TV remote isn't programmed in isolation anymore. The vendor of the TV also has to provide a whole firmware update process; has to provide a way for the remote and the TV to interact during configuration; has to think about users who want to upload profiles of their remote settings to the company's web site, so they can be persisted across upgrades and converted into equivalent choices in a smartphone app.

Nanobots achieve goals as a swarm.

3D printers have user forums and public blueprint-sharing sites and import-from-sketchup features to support.

Auto manufacturers have to release replacement parts on a schedule that correlates to the upgraded diagnostic features and the bug fixes they offer for their onboard computers.

<strong>Implications</strong>

<a title="History of Germ Theory" href="http://www.sciencemuseum.org.uk/broughttolife/techniques/germtheory.aspx" target="_blank">Germ theory</a> revolutionized medicine; mortality rates plunged as doctors acknowledged for the first time how hand-washing translated into better recovery from surgery.

Software is just as interconnected. Individual chunks of code depend on one another <a title="The 8th Characteristic" href="designing-an-apex-predator.md">respect the constraints implied by one another's requirements</a>. Engineers and architects and CS professors, we have to stop thinking at the level of a single app(lication). We know we need the databases behind our app(lication), the web servers that host our UI, the people that maintain our infrastructure... When we pursue "integration" we acknowledge that we're joined at the hip to other products. Cloud computing makes our dependence on the internet explicit.

But do we get it?

We need <a title="Metrics, Plumb Lines, and System Thinking" href="why-mental-models-matter.md">model</a> entire ecosystems, in all their chaotic and evolving complexity. We need development processes that are agile for ecosystems, not just for a feature of an app.

We don't use the term "computer programming" much anymore, but when are we going to start talking about "software ecosystem engineering" instead?

Until we do, I think we're missing the boat.
<p style="padding-left:30px;text-align:center;"><strong><span style="color:#000080;">Action Item</span></strong></p>
<p style="padding-left:30px;"><span style="color:#000080;"><em>Discuss the idea of ecosystems in software with a colleague. How do you see the metaphor relating to your day-to-day work?</em></span></p>

<h6 class="zemanta-related-title" style="font-size:1em;padding-left:30px;">Related articles</h6>
<ul class="zemanta-article-ul">
	<li class="zemanta-article-ul-li"><a href="http://nathanmarz.com/blog/principles-of-software-engineering-part-1.html" target="_blank">Principles of Software Engineering, Part 1</a> (nathanmarz.com)</li>
	<li class="zemanta-article-ul-li"><a href="the-paradigm-of-the-software-developer-the-engineer-vs-the-artist-and-how-it-affects-software-development.md" target="_blank">The Paradigm of the Software Developer: the Engineer vs. the Artist and How it Affects Software Development</a> (kennethmiralles.wordpress.com)</li>
	<li class="zemanta-article-ul-li"><a href="the-origin-of-software-engineering.md" target="_blank">The origin of "software engineering"</a> (bertrandmeyer.com)</li>
</ul>

---

Andrew Titenko (2023-05-12 11:49:15)

Great blog you havee